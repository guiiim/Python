# -*- coding: utf-8 -*-
"""Desafio M2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Syn3y5FQ_1HfviVzwViRdjlRMX5PCOtW

Importando todas bibliotecas
"""

from pandas import DataFrame
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split

from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.neural_network import MLPClassifier
from sklearn.metrics import r2_score

"""Importando base de dados"""

from google.colab import files
uploaded = files.upload()

wineQ = pd.read_csv('winequality-red.csv', sep=';')

"""Visualizando dataset

Pergunta 1:

Pergunta 2:
"""

# No dataset utilizado para o desafio, quantas instâncias e atributos existem, espectivamente?

# Quantos tipos diferentes de dados existem no dataset do desafio?

print(wineQ.shape)
wineQ.info()
wineQ.head()

# (1599,12)
# 2 - float64 e int64

"""Pergunta 3:"""

# Qual é a proporção (em %) de valores nulos existente na coluna "residual sugar" (resíduo de açucar)?

wineQ['residual sugar'].isnull().sum()

# 0%

"""Pergunta 4:"""

# Qual é o desvio padrão para a variável "fixed acidity" ?
wineQ['fixed acidity'].describe()

# 1.741096

"""Pergunta 5"""

# Qual é a mediana para a variável "residual sugar"?

wineQ['residual sugar'].median()

# 2.2

"""Pergunta 6"""

# Sobre o coeficiente de correlação de Pearson entre as variáveis "fixed acidity" e "pH" é CORRETO afirmar:

plt.figure(figsize=(10, 5))
matriz_de_correlação = wineQ.corr()  #construindo a matriz de correlação
sns.heatmap(matriz_de_correlação, annot=True,vmin=-1, vmax=1, cmap="YlGnBu", center= 0)  #plotando a matriz de correlação com o seaborn
plt.show()

# Existe uma correlação negativa. Quanto maior o "fixed acidity, menor é o "pH".

"""Pergunta 7"""

# Mesmo sendo reduzido, é CORRETO dizer sobre o coeficiente de correlação de Pearson entre as variáveis "quality" e "alcohol":

# Quanto maior o teor alcoolico (alcohol), maior é a qualidade do vinho (quality).

"""Pergunta 8"""

# Quantas instâncias existem para a qualidade do vinho igual a 5?

wineQ['quality'].value_counts()

# 681

"""Pergunta 9"""

# Aplique o modelo de normalização MinMaxScaler com os valores "default" para os dados de entrada. Qual é o menor valor para a variável "fixed acidity"?

MinMaxScaler().fit_transform(wineQ[['fixed acidity','quality']]).min()

#0.0

"""Preparando os dados"""

#Separando colunas
X = wineQ.drop(columns=['quality'])
y = wineQ['quality']

#Normalizando os dados
scaler = MinMaxScaler()

#Padronizando os dados
X = scaler.fit_transform(X)

#Separando os dados
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = .3, random_state = 1)

"""Criando os modelos"""

#KNN
clf_KNN = KNeighborsClassifier(n_neighbors=5)
clf_KNN.fit(X_train, y_train)

#Decision Tree
clf_arvore = DecisionTreeClassifier()
clf_arvore.fit(X_train, y_train)

#Random Forest
clf_floresta = RandomForestClassifier(max_depth=10, random_state=1)
clf_floresta.fit(X_train, y_train)

#SVM
clf_SVM = SVC(gamma='auto', kernel='rbf')
clf_SVM.fit(X_train, y_train)

#MLP
clf_mlp = MLPClassifier(alpha=1e-5, hidden_layer_sizes=(5, 5), random_state=1)
clf_mlp.fit(X_train, y_train)

"""Pergunta 10"""

#Após dividir o dataset utilizando o método train_test_split(entradas_normalizadas, saida, test_size=0.30, random_state=1). 
#Qual foi a acurária para o KNN?

print("Acurácia: {}".format(clf_KNN.score(X_test, y_test)))

#0.5645

"""Pergunta 11"""

#Aplicando o algoritmo de árvore de decisão com os parâmetros definidos no enunciado do desafio
# e a divisão de treinamento e teste como mostrado, anteriormente. 
#Qual é o valor da acurácia?

print("Acurácia: {}".format(clf_arvore.score(X_test, y_test)))

#0.5979

"""Pergunta 12"""

#Aplicando o algoritmo de floresta randomica com os mesmos parâmetros apresentados no enunciado
# e mesmos valores treinamento e teste, qual é o valor da acurácia?

print("Acurácia: {}".format(clf_floresta.score(X_test, y_test)))

#0.6791

"""Pergunta 13"""

#Aplicando o algoritmo SVM para a classificação da qualidade dos vinhos com os mesmos valores anteriores para treinamento e teste, 
#qual é o valor de acurácia obtido?

print("Acurácia: {}".format(clf_SVM.score(X_test, y_test)))

#0.5854

"""Pergunta 14"""

#Aplicando a rede MLP como mostrado no enunciado e com os mesmos dados de treinamento e teste utilizados, 
#qual é a acurácia do modelo?

print("Acurácia: {}".format(clf_mlp.score(X_test, y_test)))

#0.6

"""Pergunta 15"""

#Modifique o dataset para um sistema binário que considere vinhos com nota maior do que 5 (6, 7, 8) sejam bons
# e menores ou igual a 5 ruins (5, 4, 3). 

wineQ['quality'] = wineQ['quality'].replace(6, 1)
wineQ['quality'] = wineQ['quality'].replace(7, 1)
wineQ['quality'] = wineQ['quality'].replace(8, 1)
wineQ['quality'] = wineQ['quality'].replace(3, 0)
wineQ['quality'] = wineQ['quality'].replace(4, 0)
wineQ['quality'] = wineQ['quality'].replace(5, 0)

X = wineQ.drop(columns=['quality'])
y = wineQ['quality']

scaler = MinMaxScaler()

X = scaler.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = .3, random_state = 1)

#Aplique o modelo da floresta randômica. Qual a acurácia do modelo para esse novo dataset?
clf_floresta = RandomForestClassifier(max_depth=10, random_state=1)
clf_floresta.fit(X_train, y_train)
print("Acurácia: {}".format(clf_floresta.score(X_test, y_test)))

#0.8041